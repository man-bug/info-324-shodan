"use server";

export type CveResult = {
    id: string;
    references: [
    {
        url: string,
        source: string,
        tags: string[],
    },
];
    tags: string[];
    description: string;
    confidentialityImpact: string;
    integrityImpact: string;
    availabilityImpact: string;
    severity: string;
};

export async function fetchCveData(modelName: string): Promise<CveResult[]> {
    if (modelName === "NULL") {
        throw new Error('Invalid model selected');
    }

    const encodedModelName = encodeURIComponent(modelName);

    try {
        const response = await fetch(`https://services.nvd.nist.gov/rest/json/cves/2.0?keywordSearch=${encodedModelName}`,
            {
                headers: {
                    apiKey: process.env.NVD_API_KEY ?? ""
                },
                cache: "force-cache"
            }
        );

        if (!response.ok) {
            throw new Error(`Failed to fetch CVEs: (${response.status}) ${response.statusText}`);
        }

        const data = await response.json();

        const extractedData: CveResult[] = data.vulnerabilities.map((vulnerability: any) => {
            const cve = vulnerability.cve;
            const metrics = cve.metrics.cvssMetricV31?.[0]?.cvssData || cve.metrics.cvssMetricV2?.[0]?.cvssData || {};
            const severity = metrics.baseSeverity || "NULL";

            return {
                id: cve.id,
                references: cve.references || [],
                tags: cve.cveTags || [],
                description: cve.descriptions.find((desc: any) => desc.lang === 'en')?.value || 'No description available',
                confidentialityImpact: metrics.confidentialityImpact || "NULL",
                integrityImpact: metrics.integrityImpact || "NULL",
                availabilityImpact: metrics.availabilityImpact || "NULL",
                severity
            };
        });

        return extractedData;
    } catch (error: any) {
        console.error('Error fetching CVEs:', error.message);
        throw new Error(error.message);
    }
}
